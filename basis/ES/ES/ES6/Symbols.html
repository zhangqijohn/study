<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Symbols</title>
</head>
<body>
<pre>
原因 #1 ——添加向后兼容的新的内核特性
    JavaScript 开发者和 ECMAScript 委员会（TC39）需要一种可以添加新的对象属性的方式，而不打破已有的方法，比如 for ... in 循环或者 JavaScript 方法 Object.keys 。
    例如，如果我有一个对象，var myObject = {firstName:'raja', lastName:'rao'} ，如果我执行 Object.keys(myObject) ，它将会返回 [firstName, lastName] 。
    现在如果我添加一个属性，也就是在 myObject 添加 newProperty 属性 ，如果我执行 Object.keys(myObject) ，那么应该仍然返回之前的值，[firstName, lastName]，而不希望返回 [firstName, lastName, newProperty] 。那么应该如何做到这一点呢？
    我们之前无法做到这一点，因此创建了一个名为 Symbols 的新数据类型。
    如果你作为一个 symbol 来添加 newProperty ，那么 Object.keys(myObject) 会无视掉这个属性（由于它不会被识别），并仍然返回 [firstName, lastName] ！


原因 #2 ——避免命名冲突
    他们也希望保持这些属性的唯一性。通过这种方式，他们可以不断向全局添加新属性（并且可以添加对象属性），而不用担心命名冲突。
    例如，你有一个对象，在对象中你正在添加一个自定义的 toUpperCase 到全局的 Array.prototype 。
    现在想象一下，你加载了另一个库（或者说 ES2019 发布了），它有一个不同版本的Array.prototype.toUpperCase 。那么你的函数可能会由于命名冲突而崩溃。

原因 #3. 众所周知的 Symbols（“全局”Symbols）
    默认情况下，JavaScript 自动创建一堆 symbol 变量，并将他们分配给全局 Symbol 对象（是的，我们使用相同的 Symbol() 去创建 symbols ）。
    在 ECMAScript 2015 中，这些 symbols 随后被添加到诸如数组和字符串等核心对象的核心方法，如 String.prototype.search 和 String.prototype.replace 。
    举一些 Symbols 的例子：Symbol.match， Symbol.replace，Symbol.search，Symbol.iterator 和 Symbol.split。
    由于这些全局 Symbols 是全局且公开的，我们可以用核心的方法调用我们自定义函数而不是内部函数。
</pre>
<script>
//可以添加新的对象属性的方式
    var obj = {};
    obj['prop1'] = 1;
    obj['prop2'] = 2;

    // Lets add some symbols to the object using "brackets"
    // (note: this MUST be via brackets)

    var prop3 = Symbol('prop3');
    var prop4 = Symbol('prop4');

    obj['prop3'] = 3;
    obj['prop4'] = 4;

    for (var key in obj) {
        console.log(key, '=', obj[key])
    }

    // The above loop prints...
    // (doesn't know about props3 and prop4)
    // prop1 = 1
    // prop2 = 2

    // however, you can access   props3 and prop4 directly via  brackets

    console.log(obj[prop3]) //3
    console.log(obj[prop4]) //4

    const obj1 = {
        name: 'raja'
    };
    //add some symbols..
    obj1[Symbol('store string')] = 'some string';
    obj1[Symbol('store fun')] = () => console.log('function');

    // symbol key properties are ignored by many other methods
    console.log(Object.keys(obj1));//['name']
    console.log(Object.getOwnPropertyNames(obj1));//['name']

// Symbol 是唯一的
    var includes = Symbol('will store custom includes methods');

    // Add it to global Attay.prototype
    Array.prototype[includes] = () => console.log('inside includes funs');

    //Usage:

    var arr = [1, 2, 3];

    // The following each call the ES2018 includes methods
    console.log(arr.includes(1)); // true
    console.log(arr['includes'](1)); // true; here is a string

    // The following calls the custom includes methods

    console.log(arr[includes]()); // 'inside includes funs'; here  includes is a symbol


// “全局”Symbols
// pseudo code for String class
class String {
    constructor(value){
        this.value=value;
    }
    search(obj) {
        // call the obj's Symbol.search method and pass my value to is
        obj[Symbol.search](this.value);
    }
}

// pseudo code for RegExp class
class RegExp {
    constructor(value){
        this.value=value;
    }
    search(obj) {
        // call the obj's Symbol.search method and pass my value to is
        Symbol.search(string){
            return string.indexOf(this.value);
        }
    }
}

// inner workings...
// 'rajarao'.search('rao');
// step1:  convert  'rajarao' to String Object... new String('rajarao');
// step2:  'rao' is a string, so convert it to RegExp object... new RegExp('rao');
// step3:  call 'rajarao's 'search' method and pass 'rao' object
// step4:  call 'rao' RegExp object's [Symbol.search]  method
// step5: return result
</script>






</body>
</html>
