<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<pre>
1. 字符的 Unicode 表示法
    ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。
"\u{41}\u{42}\u{43}" // "ABC"

2.字符串的遍历器接口
    for (let codePoint of 'foo') {
      console.log(codePoint)
    }

3.直接输入 U+2028 和 U+2029
    const json = '"\u2028"';
    JSON.parse(json); // 可能报错

4.JSON.stringify() 的改造
    JSON.stringify('\u{D834}') // ""\\uD834""
    JSON.stringify('\uDF06\uD834') // ""\\udf06\\ud834""

5.模板字符串
    // 字符串中嵌入变量
    let name = "Bob", time = "today";
    console.log(`Hello ${name}, how are you ${time}?`)

6.实例：模板编译
    let template = `
            <ul>
                <% for(let i=0; i < data.supplies.length; i++) { %>
                <li><%= data.supplies[i] %></li>
                <% } %>
            </ul>
        `;

7.标签模板
    let a = 5;
    let b = 10;

    tag`Hello ${ a + b } world ${ a * b }`;
    // 等同于
    tag(['Hello ', ' world ', ''], 15, 50);

8.字符串的新增方法
    String.fromCodePoint() String.fromCharCode(0x20BB7) ==》 String.fromCodePoint(0x20BB7) // "𠮷"
    String.raw() String.raw`Hi\\n` === "Hi\\\\n" // true 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。
    实例方法：codePointAt()
    实例方法：normalize()
    实例方法：includes(), startsWith(), endsWith()
    实例方法：repeat() // 方法返回一个新字符串，表示将原字符串重复n次。
    实例方法：padStart()，padEnd()
    实例方法：trimStart()，trimEnd()
    实例方法：matchAll()



</pre>
<script >
    var _string = 'hell\u{6F}'
    for(let i = 0;i<_string.length;i++){
        console.log(_string[i])
    }
    // 新增
    for(let i of _string){
        console.log(i)
    }
    var s = "𠮷";

    s.length // 2
    s.charAt(0) // ''
    s.charAt(1) // ''
    s.charCodeAt(0) // 55362
    s.charCodeAt(1) // 57271
    // NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
    // NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
    // NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
    // NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
    '\u01D1'.normalize() === '\u004F\u030C'.normalize()
    '\u004F\u030C'.normalize('NFC').length // 1
    '\u004F\u030C'.normalize('NFD').length // 2

    // includes()：返回布尔值，表示是否找到了参数字符串。
    // startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
    // endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

    'x'.padStart(5, 'ab') // 'ababx'
    'x'.padStart(4, 'ab') // 'abax'

    'x'.padEnd(5, 'ab') // 'xabab'
    'x'.padEnd(4, 'ab') // 'xaba'
    console.log(String.raw`Hi\\n` === "Hi\\\\n" )

    const s = '  abc  ';

    s.trim() // "abc"
    s.trimStart() // "abc  "
    s.trimEnd() // "  abc"

    matchAll()  // 方法返回一个正则表达式在当前字符串的所有匹配
</script>



<h3>字符串</h3>
<p>
    1.多了两个新方法 startsWith 、 endsWith;
    2.字符串模板`(返单引号);

</p>

<pre>
let str = "https://yzsy.q1.com/index.html"
if(str.startsWith("http://")) {
    alert("普通地址")

}else if(str.startsWith("https://")){
    alert("加密地址")
}

if(str.endsWith(".html")) {
    alert("html")

}else{
    alert("其他")
}


</pre>


<script>
    //新方法
    let str = "https://yzsy.q1.com/index.html"
    if(str.startsWith("http://")) {
        document.write("普通地址"+"<br/>")

    }else if(str.startsWith("https://")){
        document.write("加密地址"+"<br/>")
    }

    if(str.endsWith(".html")) {
        document.write("html"+"<br/>")

    }else{
        document.write("其他")
    }

//字符串模板
//    var str1 = "<div>\
//                <h1>网址"+str+"</h1>\
//                </div>";
//等同于
let str1 = `<div>
            <h1>网址${str}</h1>
            </div>`;

    document.write(str1)
</script>







</body>
</html>
