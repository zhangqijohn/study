<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Object</title>
</head>
<body>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">参考地址 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object</a>
<pre>
    语法节
// 对象初始化器（Object initialiser）或对象字面量（literal）
{ [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] }

// 以构造函数形式来调用
new Object([value])
参数节
nameValuePair1, nameValuePair2, ... nameValuePairN
成对的名称（字符串）与值（任何值），其中名称通过冒号与值分隔。
value
任何值。
描述节
Object 构造函数为给定值创建一个对象包装器。如果给定值是 null 或 undefined，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。

当以非构造函数形式被调用时，Object 等同于 new Object()。

可查看 对象初始化/字面量语法。

Object 构造函数的属性节
Object.length
值为 1。
Object.prototype
可以为所有 Object 类型的对象添加属性。
Object 构造函数的方法节
Object.assign()
通过复制一个或多个对象来创建一个新的对象。
Object.create()
使用指定的原型对象和属性创建一个新对象。
Object.defineProperty()
给对象添加一个属性并指定该属性的配置。
Object.defineProperties()
给对象添加多个属性并分别指定它们的配置。
Object.entries()
返回给定对象自身可枚举属性的 [key, value] 数组。
Object.freeze()
冻结对象：其他代码不能删除或更改任何属性。
Object.getOwnPropertyDescriptor()
返回对象指定的属性配置。
Object.getOwnPropertyNames()
返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。
Object.getOwnPropertySymbols()
返回一个数组，它包含了指定对象自身所有的符号属性。
Object.getPrototypeOf()
返回指定对象的原型对象。
Object.is()
比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。
Object.isExtensible()
判断对象是否可扩展。
Object.isFrozen()
判断对象是否已经冻结。
Object.isSealed()
判断对象是否已经密封。
Object.keys()
返回一个包含所有给定对象自身可枚举属性名称的数组。
Object.preventExtensions()
防止对象的任何扩展。
Object.seal()
防止其他代码删除对象的属性。
Object.setPrototypeOf()
设置对象的原型（即内部 [[Prototype]] 属性）。
Object.values()
返回给定对象自身可枚举值的数组。
Object 实例和 Object 原型对象节
JavaScript中的所有对象都来自 Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。例如，其他构造函数的原型将覆盖 constructor 属性并提供自己的 toString() 方法。Object 原型对象的更改将传播到所有对象，除非受到这些更改的属性和方法将沿原型链进一步覆盖。

属性节
Object.prototype.constructor
特定的函数，用于创建一个对象的原型。
Object.prototype.__proto__
指向当对象被实例化的时候，用作原型的对象。
Object.prototype.__noSuchMethod__
当未定义的对象成员被调用作方法的时候，允许定义并执行的函数。
Object.prototype.__count__
用于直接返回用户定义的对象中可数的属性的数量。已被废除。
Object.prototype.__parent__
用于指向对象的内容。已被废除。
方法节
Object.prototype.__defineGetter__()
关联一个函数到一个属性。访问该函数时，执行该函数并返回其返回值。
Object.prototype.__defineSetter__()
关联一个函数到一个属性。设置该函数时，执行该修改属性的函数。
Object.prototype.__lookupGetter__()
返回使用 __defineGetter__ 定义的方法函数 。
Object.prototype.__lookupSetter__()
返回使用 __defineSetter__ 定义的方法函数。
Object.prototype.hasOwnProperty()
返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。
Object.prototype.isPrototypeOf()
返回一个布尔值，表示指定的对象是否在本对象的原型链中。
Object.prototype.propertyIsEnumerable()
判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。
Object.prototype.toSource()
返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象。
Object.prototype.toLocaleString()
直接调用 toString()方法。
Object.prototype.toString()
返回对象的字符串表示。
Object.prototype.unwatch()
移除对象某个属性的监听。
Object.prototype.valueOf()
返回指定对象的原始值。
Object.prototype.watch()
给对象的某个属性增加监听。
Object.prototype.eval()
在指定对象为上下文情况下执行javascript字符串代码，已经废弃。
示例节
给定 undefined 和 null 类型使用 Object节
下面的例子将一个空的 Object 对象存到 o 中：

var o = new Object();
var o = new Object(undefined);
var o = new Object(null);
使用 Object 生成布尔对象节
下面的例子将Boolean 对象存到 o 中：

// 等价于 o = new Boolean(true);
var o = new Object(true);
// 等价于 o = new Boolean(false);
var o = new Object(Boolean());
</pre>
已废弃 : 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。
警告: 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。
<pre>
    属性
Object.prototype                            表示 Object 的原型对象。
Object.prototype.__count__ 已废弃          属性曾经用来存放对象的可枚举的属性的个数，但是已经被废除。
Object.prototype.__noSuchMethod__ 已废弃   属性曾经是指当调用某个对象里不存在的方法时即将被执行的函数，但是现在这个函数已经不可用。ECMAScript 2015 (ES6) 规范转而采用 Proxy 对象
Object.prototype.__parent__ 已废弃         指向一个对象的上下文.
Object.prototype.__proto__ 警告            属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。采用Object.create() 的一个替代
Object.prototype.constructor               返回创建实例对象的 Object 构造函数的引用。
    方法
Object.assign()                             用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.create()                             创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
Object.defineProperties()                   直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
Object.defineProperty()                     直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
Object.entries()                            返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
Object.freeze()                             方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
Object.fromEntries()
Object.getNotifier()
Object.getOwnPropertyDescriptor()
Object.getOwnPropertyDescriptors()
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.getPrototypeOf()
Object.is()
Object.isExtensible()
Object.isFrozen()
Object.isSealed()
Object.keys()
Object.observe()
Object.preventExtensions()
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
Object.prototype.eval()
Object.prototype.hasOwnProperty()
Object.prototype.isPrototypeOf()
Object.prototype.propertyIsEnumerable()
Object.prototype.toLocaleString()
Object.prototype.toSource()
Object.prototype.toString()
Object.prototype.unwatch()
Object.prototype.valueOf()
Object.prototype.watch()
Object.seal()
Object.setPrototypeOf()
Object.unobserve()
Object.values()
    继承
Function
    属性
Function.arguments
Function.arity
Function.caller
Function.displayName
Function.length
Function.prototype
Function.name
    方法
Function.prototype.apply()
Function.prototype.bind()
Function.prototype.call()
Function.prototype.isGenerator()
Function.prototype.toSource()
Function.prototype.toString()
</pre>

<script>
// Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
// Object.assign(target, ...sources)
    var obj = { a: 1 };
    var copy = Object.assign({}, obj);
    console.log(copy); // { a: 1 }

// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
// Object.create(proto[, propertiesObject])
    // Shape - 父类(superclass)
    function Shape() {
        this.x = 0;
        this.y = 0;
    }
    // 父类的方法
    Shape.prototype.move = function(x, y) {
        this.x += x;
        this.y += y;
        console.info('Shape moved.');
    };
    // Rectangle - 子类(subclass)
    function Rectangle() {
        Shape.call(this); // call super constructor.
    }
    // 子类续承父类
    Rectangle.prototype = Object.create(Shape.prototype);
    Rectangle.prototype.constructor = Rectangle;
    var rect = new Rectangle();

// Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
// Object.defineProperties(obj, props)
    // obj : 在其上定义或修改属性的对象。
    // props: 要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：
    //         configurable 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 false
    //         enumerable 当且仅当在枚举相应对象上的属性时该属性显现。 默认为 false
    //         value 与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。默认为 undefined.
    //         writable 当且仅当与该属性相关联的值可以用assignment operator改变时。 默认为 false
    //         get 作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefined
    //         set 作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。默认为 undefined
    var objDefineProperties = {};
    Object.defineProperties(objDefineProperties, {
        'property1': {
            value: true,
            writable: true
        },
        'property2': {
            value: 'Hello',
            writable: false
        }
    });

// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
// Object.defineProperty(obj, prop, descriptor)
// obj: 要在其上定义属性的对象。
// prop:要定义或修改的属性的名称。
// descriptor:将被定义或修改的属性描述符。


//  Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
// Object.entries(obj)
    var objEntries = { foo: 'bar', baz: 42 };
    console.log(Object.entries(objEntries)); // [ ['foo', 'bar'], ['baz', 42] ]
    // for (let [key, value] of Object.entries(objEntries)) {
    //     console.log(`${key}: ${value}`);
    // }

// Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
// Object.freeze(obj)
    Object.freeze(objEntries);
    objEntries.baz = 33;
    objEntries.prop = 33;
    console.log(objEntries.baz,objEntries.prop); // 42 undefined

//  Object.fromEntries() 方法把键值对列表转换为一个对象。
// Object.fromEntries(iterable); // iterable 可迭代对象，类似 Array 、 Map 或者其它实现了可迭代协议的对象。
    var map = new Map([ ['foo', 'bar'], ['baz', 42] ]);
    var objMap = Object.fromEntries(map);
    console.log(objMap); // { foo: "bar", baz: 42 }

// Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
// Object.getOwnPropertyDescriptor(obj, prop)
    let o = { bar: 42 };
    let d = Object.getOwnPropertyDescriptor(o, "bar");
    if(d){console.log(d)} // {value: 42, writable: true, enumerable: true, configurable: true}

// Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。
// Object.getOwnPropertyDescriptors(obj)



// Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
// Object.getOwnPropertyNames(obj)
    var arrGetOwnPropertyNames = ["a", "b", "c"];
    console.log(Object.getOwnPropertyNames(arrGetOwnPropertyNames)); // ["0", "1", "2", "length"]
    // 类数组对象
    var objGetOwnPropertyNames = { a: "a", b: "b", c: "c"};
    console.log(Object.getOwnPropertyNames(objGetOwnPropertyNames)); // ["a", "b", "c"]

// Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。
// Object.getOwnPropertySymbols(obj)
    var objGetOwnPropertySymbols = {};
    var aGetOwnPropertySymbols = Symbol("a");
    var bGetOwnPropertySymbols = Symbol.for("b");
    objGetOwnPropertySymbols[aGetOwnPropertySymbols] = "localSymbol";
    objGetOwnPropertySymbols[bGetOwnPropertySymbols] = "globalSymbol";
    var objectSymbols = Object.getOwnPropertySymbols(objGetOwnPropertySymbols);
    console.log(objectSymbols.length); // 2
    console.log(objectSymbols)         // [Symbol(a), Symbol(b)]
    console.log(objectSymbols[0])      // Symbol(a)

// Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。
// Object.getPrototypeOf(object)
    var proto = {};
    var objGetPrototypeOf = Object.create(proto);
    Object.getPrototypeOf(objGetPrototypeOf) === proto; // true

    var regGetPrototypeOf = /a/;
    Object.getPrototypeOf(regGetPrototypeOf) === RegExp.prototype; // true


// Object.is() 方法判断两个值是否是相同的值。
// Object.is(value1, value2);
    Object.is('foo', 'bar');     // false
    Object.is([], []);           // false


// Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。
    // 新对象默认是可扩展的.
    var empty = {};
    Object.isExtensible(empty); // === true
    // ...可以变的不可扩展.
    Object.preventExtensions(empty);
    Object.isExtensible(empty); // === false
    // 密封对象是不可扩展的.
    var sealed = Object.seal({});
    Object.isExtensible(sealed); // === false
    // 冻结对象也是不可扩展.
    var frozen = Object.freeze({});
    Object.isExtensible(frozen); // === false


// Object.isFrozen()方法判断一个对象是否被冻结。
// 使用Object.freeze是冻结一个对象最方便的方法.
    var frozen = { 1: 81 };
    Object.isFrozen(frozen) //=== false
    Object.freeze(frozen);
    Object.isFrozen(frozen) //=== true
    // 一个冻结对象也是一个密封对象.
    Object.isSealed(frozen) //=== true
    // 当然,更是一个不可扩展的对象.
    Object.isExtensible(frozen) //=== false


// Object.isSealed() 方法判断一个对象是否被密封。
    // 新建的对象默认不是密封的.
    var emptyIsSealed = {};
    Object.isSealed(emptyIsSealed); // === false

    // 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.
    Object.preventExtensions(emptyIsSealed);
    Object.isSealed(emptyIsSealed); // === true

    // 但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.
    var hasProp = { fee: "fie foe fum" };
    Object.preventExtensions(hasProp);
    Object.isSealed(hasProp); // === false

    // 如果把这个属性变的不可配置,则这个对象也就成了密封对象.
    Object.defineProperty(hasProp, "fee", { configurable: false });
    Object.isSealed(hasProp); // === true

    // 最简单的方法来生成一个密封对象,当然是使用Object.seal.
    var sealed = {};
    Object.seal(sealed);
    Object.isSealed(sealed); // === true

    // 一个密封对象同时也是不可扩展的.
    Object.isExtensible(sealed); // === false

    // 一个密封对象也可以是一个冻结对象,但不是必须的.
    Object.isFrozen(sealed); // === true ，所有的属性都是不可写的
    var s2 = Object.seal({ p: 3 });
    Object.isFrozen(s2); // === false， 属性"p"可写

    var s3 = Object.seal({ get p() { return 0; } });
    Object.isFrozen(s3); // === true ，访问器属性不考虑可写不可写,只考虑是否可配置

// Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。
    var arrKeys = ['a', 'b', 'c'];
    console.log(Object.keys(arrKeys)); // console: ['0', '1', '2']

    // array like object
    var objKeys = { 0: 'a', 1: 'b', 2: 'c' };
    console.log(Object.keys(objKeys)); // console: ['0', '1', '2']

// Object.observe() 方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。你可以使用更通用的 Proxy 对象替代。
// Object.observe(obj, callback[, acceptList])
//     var objObserve = {
//         foo: 0,
//         bar: 1
//     };
//     Object.observe(objObserve, function(changes) {
//         console.log(changes);
//     });
//     objObserve.baz = 2; // [{name: 'baz', object: <obj>, type: 'add'}]
//     objObserve.foo = 'hello'; // [{name: 'foo', object: <obj>, type: 'update', oldValue: 0}]
//     delete objObserve.baz; // [{name: 'baz', object: <obj>, type: 'delete', oldValue: 2}]


// Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。语法: Object.preventExtensions(obj)
    // Object.preventExtensions将原对象变的不可扩展,并且返回原对象.
    var objPreventExtensions = {};
    var objPreventExtensions2 = Object.preventExtensions(objPreventExtensions);
    objPreventExtensions === objPreventExtensions2;  // true
    //
    // // 字面量方式定义的对象默认是可扩展的.
    // var empty = {};
    // Object.isExtensible(empty) //=== true
    //
    // // ...但可以改变.
    // Object.preventExtensions(empty);
    // Object.isExtensible(empty) //=== false
    //
    // // 使用Object.defineProperty方法为一个不可扩展的对象添加新属性会抛出异常.
    // var nonExtensible = { removable: true };
    // Object.preventExtensions(nonExtensible);
    // Object.defineProperty(nonExtensible, "new", { value: 8675309 }); // 抛出TypeError异常
    //
    // // 在严格模式中,为一个不可扩展对象的新属性赋值会抛出TypeError异常.
    // function fail()
    // {
    //     "use strict";
    //     nonExtensible.newProperty = "FAIL"; // throws a TypeError
    // }
    // fail();
    //
    // // 一个不可扩展对象的原型是不可更改的,__proto__是个非标准魔法属性,可以更改一个对象的原型.
    // var fixed = Object.preventExtensions({});
    // fixed.__proto__ = { oh: "hai" }; // 抛出TypeError异常

// Object.prototype.__defineGetter__() 可以将一个函数绑定在当前对象的指定属性上，当那个属性的值被读取时，你所绑定的函数就会被调用。 语法:obj.__defineGetter__(prop, func)
// 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。
    // 请注意，该方法是非标准的：
    var oDefineGetter = {};
    oDefineGetter.__defineGetter__('gimmeFive', function() { return 5; });
    console.log(oDefineGetter.gimmeFive); // 5

    // 请尽可能使用下面的两种推荐方式来代替：
    // 1. 在对象字面量中使用 get 语法
    var oDefineGetter1 = { get gimmeFive() { return 5; } };
    console.log(oDefineGetter1.gimmeFive); // 5

    // 2. 使用 Object.defineProperty 方法
    var oDefineGetter2 = {};
    Object.defineProperty(oDefineGetter2, 'gimmeFive', {
        get: function() {
            return 5;
        }
    });
    console.log(oDefineGetter2.gimmeFive); // 5

// __defineSetter__ 方法可以将一个函数绑定在当前对象的指定属性上，当那个属性被赋值时，你所绑定的函数就会被调用。语法:obj.__defineSetter__(prop, fun)
// 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。

// Object.prototype.__lookupGetter__() 会返回当前对象上指定属性的属性读取访问器函数（getter）。
// 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。


// Object.prototype.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是是否有指定的键）。语法:obj.hasOwnProperty(prop)
    o = new Object();
    o.prop = 'exists';
    o.hasOwnProperty('prop');             // 返回 true
    o.hasOwnProperty('toString');         // 返回 false
    o.hasOwnProperty('hasOwnProperty');   // 返回 false

// Object.prototype.isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。 语法:prototypeObj.isPrototypeOf(object)
//     function Foo() {}
//     function Bar() {}
//     function Baz() {}
//     Bar.prototype = Object.create(Foo.prototype);
//     Baz.prototype = Object.create(Bar.prototype);
//     var baz = new Baz();
//     console.log(Baz.prototype.isPrototypeOf(baz)); // true
//     console.log(Bar.prototype.isPrototypeOf(baz)); // true
//     console.log(Foo.prototype.isPrototypeOf(baz)); // true
//     console.log(Object.prototype.isPrototypeOf(baz)); // true


// Object.prototype.propertyIsEnumerable()  方法返回一个布尔值，表示指定的属性是否可枚举。语法:obj.propertyIsEnumerable(prop)
//     var o = {};
//     var a = [];
//     o.prop = 'is enumerable';
//     a[0] = 'is enumerable';
//
//     o.propertyIsEnumerable('prop');   //  返回 true
//     a.propertyIsEnumerable(0);        // 返回 true


// Object.prototype.toLocaleString() 方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。 语法:obj.toLocaleString();
    var objToLocaleString = {a:'is enumerable'}
console.log(objToLocaleString.toLocaleString())

// toSource()方法返回一个表示对象源代码的字符串。


// Object.prototype.valueOf()  方法返回指定对象的原始值。 语法:object.valueOf()
    // Array：返回数组对象本身
    var array = ["ABC", true, 12, -5];
    console.log(array.valueOf() === array);   // true

    // Date：当前时间距1970年1月1日午夜的毫秒数
    var date = new Date(2013, 7, 18, 23, 11, 59, 230);
    console.log(date.valueOf());   // 1376838719230

    // Number：返回数字值
    var num =  15.26540;
    console.log(num.valueOf());   // 15.2654

    // 布尔：返回布尔值true或false
    var bool = true;
    console.log(bool.valueOf() === bool);   // true

    // new一个Boolean对象
    var newBool = new Boolean(true);
    // valueOf()返回的是true，两者的值相等
    console.log(newBool.valueOf() == newBool);   // true
    // 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型
    console.log(newBool.valueOf() === newBool);   // false

    // Function：返回函数本身
    function foo(){}
    console.log( foo.valueOf() === foo );   // true
    var foo2 =  new Function("x", "y", "return x + y;");
    console.log( foo2.valueOf() );
    // Object：返回对象本身
    var obj = {name: "张三", age: 18};
    console.log( obj.valueOf() === obj );   // true

    // String：返回字符串值
    var str = "http://www.xyz.com";
    console.log( str.valueOf() === str );   // true


// Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。 语法:Object.seal(obj)
    var object1Seal = {
        property1: 42
    };

    Object.seal(object1Seal);
    object1Seal.property1 = 33;
    console.log(object1Seal.property1);
    // expected output: 33

    delete object1Seal.property1; // cannot delete when sealed
    console.log(object1Seal.property1);
    // expected output: 33


// Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。语法:Object.setPrototypeOf(obj, prototype)
// 警告: 由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。
    // var dictSetPrototypeOf = Object.setPrototypeOf({}, null);

// Object.unobserve() 是用来移除通过 Object.observe()设置的观察者的方法。

// Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 语法:Object.values(obj)
var objValues = { foo: 'bar', baz: 42 };
console.log(Object.values(objValues)); // ['bar', 42]

// Function 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。
var sumFunction = new Function('a', 'b', 'return a + b');
console.log(sumFunction(2, 6));














</script>
</body>
</html>
