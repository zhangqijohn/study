<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Array</title>
    <style>
        table.reference{border-collapse:collapse;width:680px;margin-bottom:4px;margin-top:4px}
        table.reference tr:nth-child(odd){background-color:#f6f4f0}
        table.reference th { color: #fff; background-color: #555;border: 1px solid #555;font-size: 12px;padding: 3px;vertical-align: top;text-align: left;}
        table.reference td{line-height:2em;min-width:24px;border:1px solid #d4d4d4;padding:5px;padding-top:7px;padding-bottom:7px;vertical-align:top}
    </style>
</head>
<body>
<pre>
1.如何判断一个变量是否是数组
 Array.isArray(arr)
 Object.prototype.toString.call(arr) === '[object Array]'
 arr.constructor === Array
 arr instanceof Array


2.如何将类数组的变量转化为数组？
Array.form()
Array.pototype.silce.call()

3.会改变自身的方法：copyWithin、fill、pop、push、reverse、shift、sort、splice、unshift
不会改变自身的方法：concat、includes、join、slice、toSource、toString、toLocaleString、indexOf、lastIndexOf
遍历方法： forEach、filter、find、map、some、every、entries、keys、values、ruduce、ruduceRight

4.数组取最大值、最小值
var arr = [1,32,4,5,6,7,87]
取最大：Math.max.apply(null, arr)
取最小：Math.min.apply(null, arr)


</pre>
<script>
    console.log(new Promise())

    // 1.如何判断一个变量是否是数组
    var arr = [1, 2, 3];
    // 方法一 ES6： Array.isArray(arr)
    console.log(Array.isArray(arr)) // true

    // 方法二 ES5： Object.prototype.toString.call(arr) === '[object Array]'
    console.log(Object.prototype.toString.call(arr) === '[object Array]') // true

    // 方法三 ES5： arr.constructor === Array  arr instanceof Array
    // 缺陷：frame嵌套的情况下，每一个的引用地址都是不同的，比较起来结果也是不确定的，所以这种方法有其局限性。不建议使用
    console.log(arr.constructor === Array) // true
    console.log(arr instanceof Array)   // true

    // 2.如何将类数组的变量转化为数组？
    let obj = {0: "a", 1: "b", 2: 3, length: 3, push: Array.prototype.push}
    // 方法一 ES6：
    console.log(Array.from(obj)) // ["a", "b", 3]
    // 方法一 ES5：不确定环境下使用
    console.log(Array.prototype.slice.call(obj))  // ["a", "b", 3]
</script>

<h4>数组去重的几种方法</h4>
<pre>
    1.Set去重: Array.from(new Set(array))
    2.创建一个[]与{}，利用对象的属性不能相同的特点
    3.利用hasOwnProperty 判断是否存在对象属性，obj.hasOwnProperty(typeof array[i])
    4.创建一个[]，利用indexOf去重
    5.创建一个[]，利用includes去重 高版本使用
    6.利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对
    7.利用for嵌套for，然后splice去重
    8.利用Map数据结构去重
</pre>

<script>
    // 利用ES6 Set去重（ES6中最常用） 不考虑兼容性，这种去重的方法代码最少，且性能非常好。
    // 缺陷：这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    function unique1 (array) {
        return Array.from(new Set(array))
        //  return [...new Set(array)]
    }
    console.log(unique1(arr)) // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]


    // 利用一个空Object来实现,利用对象的属性不能相同的特点
    // 缺陷：Boolean值 true被过滤
    function unique2(array) {
        var tmp = {},
            res = [];
        for(var i=0, max=array.length; i < max; i++){
            !tmp[array[i]] && res.push(array[i]) && (tmp[array[i]] = true)
        }
        return res
    }
    // console.log(unique2(arr)) //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]

    // 利用hasOwnProperty 判断是否存在对象属性
    // 所有的都去重了,It's so great
    function unique3(array) {
        if (Object.prototype.toString.call(arr) !== '[object Array]') {  return  }
        var obj = {},
            newArray = []
        for(var i=0, max=array.length; i < max; i++) {
            // console.log(obj.hasOwnProperty(typeof array[i]), typeof array[i] + array[i])
            if(!obj.hasOwnProperty(typeof array[i] + array[i])){
                newArray.push(array[i])
                obj[typeof array[i] + array[i]] = true
            }
        }
        return newArray
        // es6 写法
        // return array.filter(i => {
        //     return obj.hasOwnProperty(typeof i + i) ? false : (obj[typeof i + i] = true)
        // })
    }
    console.log(unique3(arr)) // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}]


    // 利用indexOf去重;新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。
    // 缺陷：NaN ，{} 未去重成功
    function unique4(array) {
        var newArray = []
        for(var i=0, max=array.length; i < max; i++) {
            (newArray.indexOf(array[i]) === -1) && newArray.push(array[i])
        }
        return newArray
    }
    // console.log(unique4(arr)) // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {}, {}]

    // 利用includes，创建一个空数组 edge 12上使用
    // 缺陷：{} 未去重成功
    function unique5(array) {
        if (!Array.isArray(array)) {  return  }
        var newArray = []
        for(var i=0, max=array.length; i < max; i++) {
            (newArray.includes(array[i]) === false) && newArray.push(array[i])
        }
        return newArray
    }
    console.log(unique5(arr)) // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]

    // 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。
    // 缺陷：NaN ，{} 未去重成功
    function unique6(array) {
        array = array.sort()
        var newArray = []
        for(var i=0, max=array.length; i < max; i++) {
            (array[i] !== array[i-1]) && newArray.push(array[i])
        }
        return newArray
    }
    // console.log(unique6(arr)) // [0, 1, 15, NaN, NaN, "NaN", {}, {}, "a", false, null, "true", true, undefined]

    // 利用for嵌套for，然后splice去重（ES5中常用）
    // 缺陷：改变了原数组；NaN ，{} 未去重成功
    function unique7(array) {
        for(var i = 0, max = array.length; i < max; i++) {
            for(var j = i + 1; j < array.length; j++) {
                (array[i] === array[j]) && (array.splice(j, 1), j--)
            }
        }
        return array
    }
    // console.log(unique7(arr)) // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {}, {}]


    // 利用filter,当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    // 缺陷：NaN 被过滤；{} 未去重成功
    function unique8(arr) {
        return arr.filter(function(item, index, arr) {
            return arr.indexOf(item, 0) === index;
        });
    }
    console.log(unique8(arr)) // [1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]

    // 利用Map数据结构去重
    // 缺陷：{} 未去重成功
    function unique9(arr) {
        let map = new Map();
        let array = new Array();  // 数组用于返回结果
        for (let i = 0; i < arr.length; i++) {
            if(map.has(arr[i])) {  // 如果有该key值
                map.set(arr[i], true);
            } else {
                map.set(arr[i], false);   // 如果没有该key值
                array.push(arr[i]);
            }
        }
        return array ;
    }
    console.log(unique9(arr)) // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]

   console.log(arr)

    // 二维数组按行排序
    function sortArr(arr) {
        var goNext = true;
        var entries = arr.entries();
        while (goNext) {
            var result = entries.next();
            if (result.done !== true) {
                result.value[1].sort((a, b) => a - b);
                goNext = true;
            } else {
                goNext = false;
            }
        }
        return arr;
    }

    var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];
    sortArr(arr); // [[1, 34], [2, 3, 44, 234, 456], [1, 4, 5, 6, 4567], [1, 23, 34, 78]]
</script>




<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">参考地址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a>

<pre>
    属性
Array.length
Array.prototype
Array.prototype[@@unscopables]
    方法
Array.from()    // 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。 语法:Array.from(arrayLike[, mapFn[, thisArg]])  返回值:一个新的数组实例
Array.isArray() // 是否是一个 Array。 语法:Array.isArray(obj) 返回值:如果对象是 Array，则为true; 否则为false。
Array.observe() 该特性是非标准的，请尽量不要在生产环境中使用它！
Array.of()  // 语法:Array.of(element0[, element1[, ...[, elementN]]]) 返回值:新的 Array 实例。
Array.prototype.concat() // 合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。语法：var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) 返回值：新的 Array 实例。
Array.prototype.copyWithin() // 浅复制数组的一部分到同一数组中的另一个位置，并返回它，会改变原数组但不会改变原数组的长度。语法： arr.copyWithin(target[, start[, end]]) 返回值：改变后的数组。
Array.prototype.entries()   // 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 语法： arr.entries() 返回值：一个新的 Array 迭代器对象
Array.prototype.every() // 测试一个数组内的所有元素是否都能通过某个指定函数的测试。arr.every(callback(element[, index[, array]])[, thisArg]) 返回值:如果回调函数的每一次返回都为 truthy 值，返回 true ，否则返回 false。
Array.prototype.fill()  // 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 语法：arr.fill(value[, start[, end]]) 返回值:修改后的数组。
Array.prototype.filter() // 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。语法:var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])。 返回值:一个新的，有通过测试的的元素组成的新数组；若没有任何元素通过，则返回空数组。
Array.prototype.find() // 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。语法:arr.find(callback[, thisArg])     返回值:数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。
Array.prototype.findIndex() //返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。    语法:arr.findIndex(callback[, thisArg])     返回值:数组中通过提供测试函数的第一个元素的索引。否则，返回-1
Array.prototype.flat() //按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。  语法:var newArray = arr.flat([depth])     返回值:
Array.prototype.flatMap() // 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。// 语法： var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {// 返回新数组的元素
Array.prototype.forEach() // 对数组的每个元素执行一次提供的函数。 语法：arr.forEach(callback[, thisArg]);
Array.prototype.includes() 用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。语法：arr.includes(valueToFind[, fromIndex]) 返回值:返回一个布尔值 Boolean
Array.prototype.indexOf() 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法：arr.indexOf(searchElement[, fromIndex = 0])    返回值:首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1
Array.prototype.join() //将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 语法:arr.join([separator])     返回值:一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串。
Array.prototype.keys() //返回一个包含数组中每个索引键的Array Iterator对象。 语法:arr.keys()     返回值:一个新的 Array 迭代器对象。
Array.prototype.lastIndexOf() //返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 语法:arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])     返回值:数组中最后一个元素的索引，如未找到返回-1
Array.prototype.map() //创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法:var new_array = arr.map(function callback(currentValue[, index[, array]]) { Return element for new_array }[, thisArg])     返回值:一个新数组，每个元素都是回调函数的结果。
Array.prototype.pop() //从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 语法:arr.pop()     返回值:从数组中删除的元素(当数组为空时返回undefined)。
Array.prototype.push() //将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 语法:arr.push(element1, ..., elementN)     返回值:当调用该方法时，新的 length 属性值将被返回。
Array.prototype.reduce() //对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 语法:arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])     返回值:函数累计处理的结果
Array.prototype.reduceRight() //方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 语法:arr.reduceRight(callback[, initialValue])     返回值:执行之后的返回值
Array.prototype.reverse() //将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。 语法:arr.reverse()     返回值:执行之后的返回值
Array.prototype.shift() //从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。语法：arr.shift()    返回值:数组中第一个元素
Array.prototype.slice() //返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 语法:arr.slice([begin[, end]])     返回值:一个含有被提取元素的新数组。
Array.prototype.some() //测试数组中是不是有元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 语法:arr.some(callback(element[, index[, array]])[, thisArg])     返回值:只要数组中有一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false
Array.prototype.sort() //用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 语法:arr.sort([compareFunction])     返回值:排序后的数组。请注意，数组已原地排序，并且不进行复制。
Array.prototype.splice() //通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 语法:array.splice(start[, deleteCount[, item1[, item2[, ...]]]])     返回值:由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。
Array.prototype.toLocaleString() //返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。 语法: arr.toLocaleString([locales[,options]]);    返回值:表示数组元素的字符串。
Array.prototype.toSource() 该特性是非标准的，请尽量不要在生产环境中使用它！ // 返回一个字符串,代表该数组的源代码.
Array.prototype.toString() //返回一个字符串，表示指定的数组及其元素。 语法:arr.toString()     返回值:一个表示指定的数组及其元素的字符串。
Array.prototype.unshift() //将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 语法:arr.unshift(element1, ..., elementN)     返回值:执行之后的返回值
Array.prototype.values() //方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 语法:arr.values()     返回值:执行之后的返回值
Array.prototype[@@iterator]()    //和 Array.prototype.values() 属性的初始值均为同一个函数对象。 语法:arr[Symbol.iterator]()     返回值:
Array.unobserve() 该特性是非标准的，请尽量不要在生产环境中使用它！
get Array[@@species]
    继承
Function
    属性
Function.arguments
Function.arity 该特性是非标准的，请尽量不要在生产环境中使用它！
Function.caller
Function.displayName
Function.length
Function.prototype
Function.name
    方法
Function.prototype.apply()
Function.prototype.bind()
Function.prototype.call()
Function.prototype.isGenerator()
Function.prototype.toSource()
Function.prototype.toString()
Object
    属性
Object.prototype.__count__ 该特性是非标准的，请尽量不要在生产环境中使用它！
Object.prototype.__noSuchMethod__ 该特性是非标准的，请尽量不要在生产环境中使用它！
Object.prototype.__parent__ 该特性是非标准的，请尽量不要在生产环境中使用它！
Object.prototype.__proto__
Object.prototype.constructor
    方法
Object.prototype.__defineGetter__()
Object.prototype.__defineSetter__()
Object.prototype.__lookupGetter__()
Object.prototype.__lookupSetter__()
Object.prototype.hasOwnProperty()
Object.prototype.isPrototypeOf()
Object.prototype.propertyIsEnumerable()
Object.prototype.toLocaleString()
Object.prototype.toSource()
Object.prototype.toString()
Object.prototype.unwatch()
Object.prototype.valueOf()
Object.prototype.watch()
Object.setPrototypeOf()
</pre>

<script>
// Array.from
// 语法 Array.from(arrayLike[, mapFn[, thisArg]])
    Array.from('foo'); // ["f", "o", "o"]

    var s = new Set(['foo', window]);
    Array.from(s);     // ["foo", window]

    var m = new Map([[1, 2], [2, 4], [4, 8]]);
    Array.from(m);
    // [[1, 2], [2, 4], [4, 8]]

    // 数组去重合并
    function combine(){
        let arr = [].concat.apply([], arguments);  //没有去重复的新数组
        return Array.from(new Set(arr));
    }
    var m = [1, 2, 2], n = [2,3,3];
    console.log(combine(m,n)); // [1, 2, 3]

//Array.isArray() 用于确定传递的值是否是一个 Array。 语法：Array.isArray(obj)
    Array.isArray([1, 2, 3]);       // true
    Array.isArray({foo: 123});      // false
    Array.isArray("foobar");        // false
    Array.isArray(undefined);      // false

//  Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。
// 语法： Array.of(element0[, element1[, ...[, elementN]]])
    Array.of(7);       // [7]
    Array.of(1, 2, 3); // [1, 2, 3]
    Array(7);          // [ , , , , , , ]
    Array(1, 2, 3);    // [1, 2, 3]

// concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。语法： var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
    var num1 = [1, 2, 3], num2 = [4, 5, 6], num3 = [7, 8, 9];
    console.log(num1.concat(num2, num3)); // results in [1, 2, 3, 4, 5, 6, 7, 8, 9]

// copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。语法：  arr.copyWithin(target[, start[, end]])
    let numbers = [1, 2, 3, 4, 5];
    numbers.copyWithin(-2); // [1, 2, 3, 1, 2]
    numbers.copyWithin(0, 3); // [4, 5, 3, 4, 5]
    numbers.copyWithin(0, 3, 4); // [4, 2, 3, 4, 5]
    numbers.copyWithin(-2, -3, -1); // [1, 2, 3, 3, 4]
    [].copyWithin.call({length: 5, 3: 1}, 0, 3); // {0: 1, 3: 1, length: 5}
    // ES2015 Typed Arrays are subclasses of Array
    var i32a = new Int32Array([1, 2, 3, 4, 5]);
    i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]
    // On platforms that are not yet ES2015 compliant:
    [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5]


// entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 语法：arr.entries
    var array1 = ['a', 'b', 'c'];
    var iterator1 = array1.entries();
    console.log(iterator1.next().value); // expected output: Array [0, "a"]

// every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。语法： arr.every(callback[, thisArg])
    console.log( [12, 54, 18, 130, 44].every(x => x >= 10)) // true

// fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。语法：  arr.fill(value[, start[, end]])
    console.log([0,1,2,3,4].fill(0, 2, 4)); // [0, 1, 0, 0, 4]

// filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
    console.log(['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'].filter(x=>x.length > 6)) // ["exuberant", "destruction", "present"]

//  find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
    console.log([0,1,2,3,4].find(x=>x>2)); // 3

// findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。
    console.log([0,1,2,3,4].findIndex(x=>x>2)); // 3

// flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。语法：var newArray = arr.flat(depth)
// flat() 方法会移除数组中的空项:
    var arrFlat = [1, 2, [3, 4, [5, 6]]];
    console.log(arrFlat.flat()) // [1, 2, 3, 4, [5, 6]]
    console.log(arrFlat.flat(Infinity)) // [1, 2, 3, 4, 5, 6]

//  flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。
// 语法： var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {
// 返回新数组的元素
// }[, thisArg])
    var arrflatMap = ["今天天气不错", "", "早上好"]
    arrflatMap.flatMap(s => s.split('')); // ["今", "天", "天", "气", "不", "错", "早", "上", "好"]

// forEach() 方法对数组的每个元素执行一次提供的函数。 语法：arr.forEach(callback[, thisArg]);
    var  arrForEach = [0,1,2,3,4]
    arrForEach.forEach(x=>{console.log(x*2)}) //0,2,4,6,8

// includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。语法：arr.includes(valueToFind[, fromIndex])
// 注意：对象数组不能使用includes方法来检测。
    console.log(arrForEach.includes(2));     // true

// indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法：arr.indexOf(searchElement[, fromIndex = 0])
    console.log(arrForEach.indexOf(2)) // 2

// join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。  语法：arr.join([separator])
    console.log(arrForEach.join('')) // 01234

//  keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。  语法：arr.keys()
    var array1 = ['a', 'b', 'c']; var iterator = array1.keys();
        for (let key of iterator) {
        console.log(key); // expected output: 0 1 2
    }

// lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
    var animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];
    console.log(animals.lastIndexOf('Dodo')); // 3

// map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
// var new_array = arr.map(function callback(currentValue[, index[, array]]) {
//     // Return element for new_array
// }[, thisArg])
    var numbersmap = [1, 4, 9];
    var doubles = numbersmap.map(x=> x * 2);
    console.log(numbersmap)     // numbers数组未被修改： [1, 4, 9]
    console.log(doubles) // doubles数组的值为： [2, 8, 18]

// pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。
    console.log(numbersmap.pop()); // 9

// push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。
    numbersmap.push(10)
    console.log(numbersmap); // [1, 4, 10];

// reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。语法：arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
    var array1reduce = [1, 2, 3, 4];
    var reducer = (accumulator, currentValue) => accumulator + currentValue;
    console.log(array1reduce.reduce(reducer)); //10    1 + 2 + 3 + 4

var array1reduce1 = [{id:1}, {id:2}, {id:3}, {id:4}];
console.log(array1reduce1.reduce((accumulator, currentValue) => accumulator + currentValue.id)); //10    1 + 2 + 3 +

// reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 语法：arr.reduceRight(callback[, initialValue])
    var arrayreduceRight = [[0, 1], [2, 3], [4, 5]].reduceRight(
        (accumulator, currentValue) => accumulator.concat(currentValue)
    );
    console.log(arrayreduceRight) // [4, 5, 2, 3, 0, 1]

// reverse() 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。  语法：arr.reverse()
    console.log(array1reduce.reverse()) //  [4, 3, 2, 1]

// shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。语法：arr.shift()
    var myFish = ['angel', 'clown', 'mandarin', 'surgeon'];
    var shifted = myFish.shift();
    console.log('调用 shift 之后: ' + myFish); // "调用 shift 之后: clown,mandarin,surgeon"
    console.log('被删除的元素: ' + shifted); // "被删除的元素: angel"

// slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 语法：arr.slice([begin[, end]])
    var fruitsslice = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
    var citrusslice = fruitsslice.slice(1, 3);
    console.log('fruitsslice: ' + fruitsslice); // ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
    console.log('citrusslice: ' + citrusslice); // ['Orange','Lemon']

// some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。 语法:arr.some(callback(element[, index[, array]])[, thisArg])
    console.log([2, 5, 8, 1, 4].some(x => x > 10));  // false
    console.log([12, 5, 8, 1, 4].some(x => x > 10)); // true

// sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。 语法: arr.sort([compareFunction])
    var array1sort = [1, 30, 4, 21, 100000];
    console.log(array1sort.sort((a,b)=>a-b) ); // [1, 4, 21, 30, 100000]

// splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 语法: array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
    var array1splice = [1, 30, 4, 21, 100000];
    var removedsplice = array1splice.splice(2,2,"john")
    console.log(array1splice); // [1, 30, "john", 100000]
    console.log(removedsplice);// [4, 21]


// toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。 语法:arr.toLocaleString([locales[,options]]);
    console.log((new Date()).toLocaleString()) // 2019/8/30 上午9:29:48
    var pricestoLocaleString = ['￥7', 500, 8123, 12];
    console.log(pricestoLocaleString.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' })) // ￥7,￥500,￥8,123,￥12

// toString() 返回一个字符串，表示指定的数组及其元素。  语法: arr.toString()
    var array1toString = [1, 2, 'a', '1a'];
    console.log(array1toString.toString()); // 1,2,a,1a

// unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。  语法: arr.unshift(element1, ..., elementN)
    var array1unshift = [1, 2, 3];
    console.log(array1unshift.unshift(4, 5)); // expected output: 5
    console.log(array1unshift); // expected output: Array [4, 5, 1, 2, 3]

// values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值
    const array1values = ['a', 'b', 'c'];
    const iteratorarray1values = array1values.values();
    for (const value of iteratorarray1values) {
        console.log(value); // expected output: "a" "b" "c"
    }
// @@iterator 属性和 Array.prototype.values() 属性的初始值均为同一个函数对象。  语法:arr[Symbol.iterator]()
    var arriterator = ['h', 'e', 'l', 'l', 'o'];
    var eArriterator = arriterator[Symbol.iterator]();
    // 您的浏览器必须支持for...of循环
    // 以及let —— 将变量作用域限定在 for 循环中
    for (let letter of eArriterator) {
        console.log(letter);
    }


</script>



<!--
<table class="reference">
    <tr><th>方法</th><th>描述</th></tr>
    <tr><td>concat()</td><td>连接两个或更多的数组，并返回结果。</td></tr>
    <tr><td>copyWithin()</td><td>从数组的指定位置拷贝元素到数组的另一个指定位置中。</td></tr>
    <tr><td>entries()</td><td>返回数组的可迭代对象。</td></tr>
    <tr><td>every()</td><td>检测数值元素的每个元素是否都符合条件。</td></tr>
    <tr><td>fill()</td><td>使用一个固定值来填充数组。</td></tr>
    <tr><td>filter()</td><td>检测数值元素，并返回符合条件所有元素的数组。</td></tr>
    <tr><td>find()</td><td>返回符合传入测试（函数）条件的数组元素。</td></tr>
    <tr><td>findIndex()</td><td>返回符合传入测试（函数）条件的数组元素索引。</td></tr>
    <tr><td>forEach()</td><td>数组每个元素都执行一次回调函数。</td></tr>
    <tr><td>from()</td><td>通过给定的对象中创建一个数组。</td></tr>
    <tr><td>includes()</td><td>判断一个数组是否包含一个指定的值。</td></tr>
    <tr><td>indexOf()</td><td>搜索数组中的元素，并返回它所在的位置。</td></tr>
    <tr><td>isArray()</td><td>判断对象是否为数组。</td></tr>
    <tr><td>join()</td><td>把数组的所有元素放入一个字符串。</td></tr>
    <tr><td>keys()</td><td>返回数组的可迭代对象，包含原始数组的键(key)。</td></tr>
    <tr><td>lastIndexOf()</td><td>搜索数组中的元素，并返回它最后出现的位置。</td></tr>
    <tr><td>map()</td><td>通过指定函数处理数组的每个元素，并返回处理后的数组。</td></tr>
    <tr><td>pop()</td><td>删除数组的最后一个元素并返回删除的元素。</td></tr>
    <tr><td>push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr>
    <tr><td>reduce()</td><td>将数组元素计算为一个值（从左到右）。</td></tr>
    <tr><td>reduceRight()</td><td>将数组元素计算为一个值（从右到左）。</td></tr>
    <tr><td>reverse()</td><td>反转数组的元素顺序。</td></tr>
    <tr><td>shift()</td><td>删除并返回数组的第一个元素。</td></tr>
    <tr><td>slice()</td><td>选取数组的的一部分，并返回一个新数组。</td></tr>
    <tr><td>some()</td><td>检测数组元素中是否有元素符合指定条件。</td></tr>
    <tr><td>sort()</td><td>对数组的元素进行排序。</td></tr>
    <tr><td>splice()</td><td>从数组中添加或删除元素。</td></tr>
    <tr><td>toString()</td><td>把数组转换为字符串，并返回结果。</td></tr>
    <tr><td>unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr>
    <tr><td>valueOf()</td><td>返回数组对象的原始值。</td></tr>
</table>
-->



</body>
</html>
